/**
 * auc - The Aurum compiler
 * Copyright (c) 2016  Alexander Tsaregorodtsev <tuxerr.at@gmail.com>
 * Distributed under the GNU GPL v3. For full terms see the file LICENSE.
 */

 #include <string>

//TODO: Resolve LL(1) conflicts
COMPILER Aurum

    AbstractSyntaxTree* ast;


//TODO: Unicode support
CHARACTERS
    letter   = 'a'..'z' + 'A' .. 'Z'.
    digit    = '0'..'9'.
    hexdigit = digit + 'A'..'F'.
    octdigit = '0'..'7'.
    bindigit = '0'..'1'.
    idstart = letter + '_'.
    opstart = '#'.
    char = ANY.
    strdelim = '"'.

//TODO: Float and String support
TOKENS
    ident = idstart {letter}.
    opfunc = opstart {char}.
    integer =   "0x" hexdigit {hexdigit}
    |           "0b" bindigit {bindigit}
    |           "0" octdigit {octdigit}
    |           ["+" | "-"] digit {digit} ["l" | "L"].
    float ["+" | "-"] digit {digit} ["." digit {digit}] [("e" | "E") ["+" | "-"] digit {digit}] ["f" | "F" | "d" | "D"].
    string = strdelim {char} strdelim.
    //genericspec = letter | "?".
    //funcident = functionchar {functionchar}.

COMMENTS FROM "//" TO "\n"
COMMENTS FROM "/*" TO "*/"

IGNORE '\t' + '\r' + '\n' + '\f'

PRODUCTIONS

Aurum   (. ast = new AST(); ASTElement elem; .)
=   { DeclarativeExpression<elem> (. ast->getDeclarations().push_back(expr); .)
    }.

DeclarativeExpression<Expression &expr> = (. Fun .)
    FunctionDeclaration<funcDecl>
|   FunctionDefinition<funcDef>
|   ConstantDefinition<constDed>.
//|   ClassDefinition   TODO: Class definition
//|   ImportDefinition  TODO: Import definition
//|   TypeDefinition    TODO: Type definition
//|   ExportBlock       TODO: Export definition

FunctionDeclaration = FunctionHeader ["{" "}"] ";".

FunctionDefinition = FunctionHeader "{" {ImperativeExpression} "}".
FunctionHeader = {FunctionModifier} Type [OperatorDeclaration] ident "(" [ParameterModifier] [ Type {"," Type}] ")".

FunctionModifier =
    "export"
|   "const"
|   "hidden".

//TODO: Array support
Type = ident ["[" GenericType "]"].

GenericType = GenericTypeSpecifier {"," GenericTypeSpecifier}.

GenericTypeSpecifier = ident  [GenericModifier Type].

GenericModifier =
    "is"
|   "has".

OperatorDeclaration = "operator" "(" integer ")" .

ParameterModifier = "\\". //TODO: Parameter Modifier Definition

ImperativeExpression =
    Block
|   Return
|   VariableDefinition
|   VariableDefinitionAssignment
|   FunctionCall
|   AssignOperator
|   UnaryOperator.

Block =
    IfCondition
|   WhileLoop.
//|   ForLoop       TODO: For loop definition
//|   SimpleBlock   TODO: Simple block definition
//|   UnsafeBlock   TODO: Unsafe block definition

IfCondition =   "if" "(" ValueExpression ")" (ImperativeExpression | "{" {ImperativeExpression} "}")
                ["else" "if" "(" ValueExpression ")" (ImperativeExpression | "{" {ImperativeExpression} "}")]
                ["else" (ImperativeExpression | "{" {ImperativeExpression} "}")].

WhileLoop = "while" "(" ValueExpression ")" (ImperativeExpression | "{" {ImperativeExpression} "}").

/*------------------------------------------------------------------------*/

//TODO: Clarify ident statements
Return<Block block, Expression &expr> =
"return"
[ident] (. expr = make_shared<ReturnStmt>(make_shared<VariableExpr>(t.val, block), CodeLocation::none), block, CodeLocation::none); .)
";".

/*------------------------------------------------------------------------*/

VariableDefinition<Block block, Expression &expr> =
ident (. if(t.val != "int") { SemErr("Only integers are currently supported."); } .)
ident (. expr = make_shared<VariableExpr>(t.val, block, CodeLocation::none); .)
";".

/*------------------------------------------------------------------------*/

VariableDefinitionAssignment<Block block, Expression &expr> = (. wchar_t* id; Expression expr1; .)
ident (. if(t.val != "int") { SemErr("Only integers are currently supported."); } .)
ident (. id = t.val; .)
"="
ValueExpression<block, expr1> (.    expr = make_shared<MethodCallExpr>(make_shared<VariableExpr>(id, block, CodeLocation::none), "=", block, CodeLocation::none);
                                    expr->getArgs().push_back(expr1); .)
";".

/*------------------------------------------------------------------------*/

FunctionCall<Block block, Expression &expr> = (. Expression expr1; .)
InlineFunctionCall (. expr = expr1.)
";".

/*------------------------------------------------------------------------*/

InlineFunctionCall<Block block, Expression &expr> = (. Expression expr1; Expression expr2; .)
ident (. expr = make_shared<FunctionCallExpr>(t.val, block, CodeLocation::none); .)
"("
[ValueExpression<block, expr1> (. expr->getParameters().push_back(expr1); .)
{","
ValueExpression<block, expr2> (. expr->getParameters().push_back(expr2); .)
}] ")".

/*------------------------------------------------------------------------*/

AssignOperator<Block block, Expression &expr> = (. wchar_t* id; Expression expr1; .)
ident (. id = t.val; .)
"="
ValueExpression<block, expr1> (.    expr = make_shared<MethodCallExpr>(make_shared<VariableExpr>(id, block, CodeLocation::none), "=", block, CodeLocation::none);
                                    expr->getArgs().push_back(make_shared<VariableExpr>(expr1, block, CodeLocation::none)); .)
";".

/*------------------------------------------------------------------------*/

UnaryOperator<Block block, Expression &expr> = (. wchar_t* id; Expression expr1; .)
ident (. id = t.val; .)
ValueExpression<block, expr1> (. expr = make_shared<MethodCallExpr>(expr1, id, block, CodeLocation::none); .)
";".

/*------------------------------------------------------------------------*/

ValueExpression<Block block, Expression &expr> = (. Expression expr1; Expression expr2; .)
ident (. id = t.val; .)
| integer (. expr = make_shared<ConstIntExpr>(id, stoi(t.val), block, CodeLocation::none); .)
| float (. SemErr("Only integer types are implemented"); .)
| string (. SemErr("Only integer types are implemented"); .)
| InlineFunctionCall<block, expr1> (. expr = expr1; .)
| "("
    ValueExpression<block, expr1> (. expr = make_shared<MethodCallExpr>(expr1, la.val, block, CodeLocation::none); .)
    ident
    ValueExpression<block, expr2> (. expr->getArgs().push_back(expr2); .)
  ")"
| ValueExpression<block, expr1> (. expr = make_shared<MethodCallExpr>(expr1, la.val, block, CodeLocation::none); .)
  ident
  ValueExpression<block, expr2>. (. expr->getArgs().push_back(expr2); .)

/*------------------------------------------------------------------------*/

//TODO: Implement const, float, string
ConstantDefinition<Block block, VariableDefAssignStmt &stmt> =
"const"
 ident (. if(t.val != "int") { SemErr("Only integer types are implemented"); } .)
 ident (. stmt = make_shared<MethodCallExpr>(make_shared<VariableExpr>(t.val, &block, CodeLocation::none), "=", &block, CodeLocation::none);.)
 "="
 integer (. stmt->getArgs().push_back(make_shared<ConstIntExpr>(t.val, stoi(t.val), block, CodeLocation::none)); .)
 | float (. SemErr("Only integer types are implemented"); .)
 | string (. SemErr("Only integer types are implemented"); .)
 ";".

END Aurum.
